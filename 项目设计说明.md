# 项目设计说明

根据提供的供应链场景，
基于FISCO-BCOS设计相关的智能合约
并详细解释智能合约是如何解决提出的问题。

#### 数据结构
- 我们基于FISCO-BCOS的pre-compiled合约Table.sol来实现原生数据库CRUL的操作，以达到对余额、信用、票据等信息的高效存储读取。

- 其中创建了三个表用于存储相关信息
    ```
    // 创建表。
    TableFactory tf = TableFactory(0x1001);
    tf.createTable("CompanyInfo", "addr", "balance,credit");
    tf.createTable("Receipts_out", "from", "addr,amount,timestamp,validity");
    tf.createTable("Receipts_in", "to", "addr,amount,timestamp,validity");
    ```
    - CompanyInfo: 由银行公正维护的公司信息及余额
    - Receipts_out：签出的所有票据信息
    - Receipts_in：收到的所有票据信息

#### 功能实现
1. 功能一：实现采购商品—签发应收账款交易上链。 
    - 应用场景：车企从轮胎公司购买一批轮胎并签订应收账款单据。
    - 分析：考虑应收帐交易上链，也就是使用公司的信用来实现原本由现金进行的交易，并签发信用票据，且该交易过程在合约调用时会自动上链。
    - 合约接口设计：
        ```
        function tradingWithCredit(address receiver, uint amount, uint validity);
        ```
        - 地址：表示应收帐的接收方
        - 金额：表示应收帐的交易金额
        - 有效期：表示应收帐的还款期限（此处使用区块时间来衡量信用凭证逾期）  

        这些参数，加上区块时间就能保证我们能生成唯一、准确、不可伪造的应收帐目上链数据
    - 流程描述
        ```
        // 1. 检查交易金额是否合法，防止恶意攻击
        require(amount > 0, "amount must be greater than zero");
        // 2. 余额检查
        uint credit = getCompanyCredit(msg.sender);
        require(credit >= amount, "You does not have enough credit");
        // 3. 使用信用进行交易金额的抵扣
        updateCompanyCredit(msg.sender, credit - amount);
        // 4. 将应收帐目存储上链
        uint timestamp = block.timestamp;
        insertReceipt("Receipts_out", toString(msg.sender), receiver, amount, timestamp, validity);
        insertReceipt("Receipts_in", toString(receiver), msg.sender, amount, timestamp, validity);
        // 5. 触发应收帐目成功上链后的事件
        emit BalanceTransactionEvent(msg.sender, receiver, amount);
        ```

2. 功能二：实现应收账款的转让上链。
    - 应用场景：轮胎公司从轮毂公司购买一笔轮毂，便将于车企的应收账款单据部分转让给轮毂公司。
    - 分析：应收账款的转让实际是将原来收到的票据进行前后金额一致的原子分割，再把其中一部分的账目持有人变更为新的持有人，该过程要保证持有的票据能正确和合法地转让
    - 合约接口设计：
        ```
        function tradingWithReceipt(address receiver, uint amount, uint timestamp);
        ```
        - 地址：表示应收帐的接收方
        - 金额：表示应收帐的交易金额
        - 时间戳：表示信用票据的签订的区块时间  

        此处的地址和金额为新持有人的信息，而时间戳则有效利用区块时间的唯一性来保证索引到唯一的信用票据，这样就能指定使用的应收账目进行转让了。
    - 流程描述
        ```
        // 1. 检查交易金额是否合法，防止恶意攻击
        require(amount > 0, "amount must be greater than zero");
        // 2. 追溯到唯一的信用票据
        Table receipt = openTable("Receipts_in");
        Condition condition = receipt.newCondition();
        condition.EQ("timestamp", int(timestamp));
        Entries entries = receipt.select(toString(msg.sender), condition);
        require(entries.size() == 1, "receipt does not exists or is not unique");
        // 3. 检查信用票据的应收账款金额和有效期限，保证转让的合法、有效
        uint timestampNOW = block.timestamp;
        Entry entry = entries.get(0);
        address addr = entry.getAddress("addr");
        uint receiptAmount = entry.getUInt("amount");
        uint validity = entry.getUInt("validity");
        require(receiptAmount >= amount, "You does not have enough receipt");
        require(timestamp + validity > timestampNOW, "Your receipt is out of date");
        // 4. 检查新的票据持有人持有的票据，同一时间戳的票据至多为1，防止时间戳与票据一一映射被破坏导致被其他人盗取应收款账目，此处的检查我们深思熟虑觉得必不可少
        entries = receipt.select(toString(receiver), condition);
        require(entries.size() <= 1, "receipt must not exists or be unique")
        // 5. 更新保留部分的凭证
        updateReceipt("Receipts_out", toString(addr), toString(msg.sender), timestamp, receiptAmount - amount);
        updateReceipt("Receipts_in", toString(msg.sender), toString(addr), timestamp, receiptAmount - amount);
        // 6. 更新分割出的部分的凭证
        if(entries.size() == 0) {
            insertReceipt("Receipts_out", toString(addr), receiver, amount, timestamp, validity);
            insertReceipt("Receipts_in", toString(receiver), addr, amount, timestamp, validity);
        }
        else {
            entry = entries.get(0);
            receiptAmount = entry.getUInt("amount");
            updateReceipt("Receipts_out", toString(addr), toString(receiver), timestamp, receiptAmount + amount);
            updateReceipt("Receipts_in", toString(receiver), toString(addr), timestamp, receiptAmount + amount);
        }
        // 7. 触发应收帐目成功分割上链后的事件
        emit CreditTransactionEvent(msg.sender, receiver, amount);

        ```

3. 功能三：利用应收账款向银行融资上链，供应链上所有可以利用应收账款单据向银行申请融资。
    - 应用场景：轮胎公司用车企给到的信用凭证向银行申请融资。
    - 分析：银行作为公证人，接受企业的应收帐票据转移应收帐目至银行，并线下对企业进行融资金额的发放，该融资交易再调用合约时会被自动上链保证不可篡改
    - 合约接口设计：
        ```
        function financing(uint amount, uint timestamp) public;
        ```
        - 地址：表示应收帐的接收方
        - 金额：表示应收帐的交易金额
        - 有效期：表示应收帐的还款期限（此处使用区块时间来衡量信用凭证逾期）  

        这些参数，加上区块时间就能保证我们能生成唯一、准确、不可伪造的应收帐目上链数据
    - 流程描述
        ```
        // 1. 检查交易金额是否合法，防止恶意攻击
        require(amount > 0, "amount must be greater than zero");
        // 2. 余额检查
        uint credit = getCompanyCredit(msg.sender);
        require(credit >= amount, "You does not have enough credit");
        // 3. 使用信用进行交易金额的抵扣
        updateCompanyCredit(msg.sender, credit - amount);
        // 4. 将应收帐目存储上链
        uint timestamp = block.timestamp;
        insertReceipt("Receipts_out", toString(msg.sender), receiver, amount, timestamp, validity);
        insertReceipt("Receipts_in", toString(receiver), msg.sender, amount, timestamp, validity);
        // 5. 触发应收帐目成功上链后的事件
        emit BalanceTransactionEvent(msg.sender, receiver, amount);
        ```



功能四：应收账款支付结算上链，应收账款单据到期时核心企业向下游企业支付相应的欠款。