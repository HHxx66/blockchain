# 项目设计说明

根据提供的供应链场景，
基于FISCO-BCOS设计相关的智能合约
并详细解释智能合约是如何解决提出的问题。

#### 数据结构
- 我们基于FISCO-BCOS的pre-compiled合约Table.sol来实现原生数据库CRUL的操作，以达到对余额、信用、票据等信息的高效存储读取。

    - 其中创建了三个表用于存储相关信息
        ```
        // 创建表。
        TableFactory tf = TableFactory(0x1001);
        tf.createTable("CompanyInfo", "addr", "balance,credit");
        tf.createTable("Receipts_out", "from", "addr,amount,timestamp,validity");
        tf.createTable("Receipts_in", "to", "addr,amount,timestamp,validity");
        ```
        - CompanyInfo: 由银行公正维护的公司信息及余额
        - Receipts_out：签出的所有票据信息
        - Receipts_in：收到的所有票据信息
- 我们使用Balance来模拟现实中的钱，而用Credit来表示企业的信用票据，以下函数命名也遵从此前提


#### 功能实现
1. 功能一：实现采购商品—签发应收账款交易上链。 
    - 应用场景：车企从轮胎公司购买一批轮胎并签订应收账款单据。
    - 分析：考虑应收帐交易上链，也就是使用公司的信用来实现原本由现金进行的交易，并签发信用票据，且该交易过程在合约调用时会自动上链。
    - 合约接口设计：
        ```
        function tradingWithCredit(address receiver, uint amount, uint validity);
        ```
        - 地址：表示应收帐的接收方
        - 金额：表示应收帐的交易金额
        - 有效期：表示应收帐的还款期限（此处使用区块时间来衡量信用凭证逾期）  

        这些参数，加上区块时间就能保证我们能生成唯一、准确、不可伪造的应收帐目上链数据
    - 流程描述
        ```
        // 1. 检查交易金额是否合法，防止恶意攻击
        require(amount > 0, "amount must be greater than zero");

        // 2. 余额检查
        uint credit = getCompanyCredit(msg.sender);
        require(credit >= amount, "You does not have enough credit");

        // 3. 使用信用进行交易金额的抵扣
        updateCompanyCredit(msg.sender, credit - amount);

        // 4. 将应收帐目存储上链
        uint timestamp = block.timestamp;
        insertReceipt("Receipts_out", toString(msg.sender), receiver, amount, timestamp, validity);
        insertReceipt("Receipts_in", toString(receiver), msg.sender, amount, timestamp, validity);

        // 5. 触发应收帐目成功上链后的事件
        emit BalanceTransactionEvent(msg.sender, receiver, amount);
        ```

2. 功能二：实现应收账款的转让上链。
    - 应用场景：轮胎公司从轮毂公司购买一笔轮毂，便将于车企的应收账款单据部分转让给轮毂公司。
    - 分析：应收账款的转让实际是将原来收到的票据进行前后金额一致的原子分割，再把其中一部分的账目持有人变更为新的持有人，该过程要保证持有的票据能正确和合法地转让
    - 合约接口设计：
        ```
        function tradingWithReceipt(address receiver, uint amount, uint timestamp);
        ```
        - 地址：表示应收帐的接收方
        - 金额：表示应收帐的交易金额
        - 时间戳：表示信用票据的签订的区块时间  

        此处的地址和金额为新持有人的信息，而时间戳则有效利用区块时间的唯一性来保证索引到唯一的信用票据，这样就能指定使用的应收账目进行转让了。
    - 流程描述
        ```
        // 1. 检查交易金额是否合法，防止恶意攻击
        require(amount > 0, "amount must be greater than zero");

        // 2. 追溯到唯一的信用票据
        Table receipt = openTable("Receipts_in");
        Condition condition = receipt.newCondition();
        condition.EQ("timestamp", int(timestamp));
        Entries entries = receipt.select(toString(msg.sender), condition);
        require(entries.size() == 1, "receipt does not exists or is not unique");

        // 3. 检查信用票据的应收账款金额和有效期限，保证转让的合法、有效
        uint timestampNOW = block.timestamp;
        Entry entry = entries.get(0);
        address addr = entry.getAddress("addr");
        uint receiptAmount = entry.getUInt("amount");
        uint validity = entry.getUInt("validity");
        require(receiptAmount >= amount, "You does not have enough receipt");
        require(timestamp + validity > timestampNOW, "Your receipt is out of date");

        // 4. 检查新的票据持有人持有的票据，同一时间戳的票据至多为1，防止时间戳与票据一一映射被破坏导致被其他人盗取应收款账目，此处的检查我们深思熟虑觉得必不可少
        entries = receipt.select(toString(receiver), condition);
        require(entries.size() <= 1, "receipt must not exists or be unique")

        // 5. 更新保留部分的凭证
        updateReceipt("Receipts_out", toString(addr), toString(msg.sender), timestamp, receiptAmount - amount);
        updateReceipt("Receipts_in", toString(msg.sender), toString(addr), timestamp, receiptAmount - amount);

        // 6. 更新分割出的部分的凭证
        if(entries.size() == 0) {
            insertReceipt("Receipts_out", toString(addr), receiver, amount, timestamp, validity);
            insertReceipt("Receipts_in", toString(receiver), addr, amount, timestamp, validity);
        }
        else {
            entry = entries.get(0);
            receiptAmount = entry.getUInt("amount");
            updateReceipt("Receipts_out", toString(addr), toString(receiver), timestamp, receiptAmount + amount);
            updateReceipt("Receipts_in", toString(receiver), toString(addr), timestamp, receiptAmount + amount);
        }

        // 7. 触发应收帐目成功分割上链后的事件
        emit CreditTransactionEvent(msg.sender, receiver, amount);

        ```

3. 功能三：利用应收账款向银行融资上链，供应链上所有可以利用应收账款单据向银行申请融资。
    - 应用场景：轮胎公司用车企给到的信用凭证向银行申请融资。
    - 分析：银行作为公证人，接受企业的应收帐票据转移应收帐目至银行，并线下对企业进行融资金额的发放，该融资交易在调用合约时会被自动上链保证不可篡改
    - 合约接口设计：
        ```
        function financing(uint amount, uint timestamp) public;
        ```
        - 金额：表示应收帐的交易金额
        - 时间戳：表示信用票据的签订的区块时间  

        金额对应融资的数量，时间戳则能追溯到唯一的票据
    - 流程描述
        ```
        // 1. 检查交易金额是否合法，防止恶意攻击
        require(amount > 0, "amount must be greater than zero");
        
        // 2. 追溯到唯一的信用票据
        Table receipt = openTable("Receipts_in");
        Condition condition = receipt.newCondition();
        condition.EQ("timestamp", int(timestamp));
        Entries entries = receipt.select(toString(msg.sender), condition);
        require(entries.size() == 1, "receipt does not exist or is not unique");

        // 3. 检查信用票据的应收账款金额，保证转让的合法、有效（这里选择不检查时间戳，是为了保证应收帐是绝对被银行保障的，即任何时刻中小企业都能安全的将应收帐的金额追回）
        Entry entry = entries.get(0);
        address addr = entry.getAddress("addr");
        uint receiptAmount = entry.getUInt("amount");
        uint validity = entry.getUInt("validity");
        require(receiptAmount >= amount, "You does not have enough receipt");

        uint balance = getCompanyBalance(adminAddr);
        require(balance >= amount, "Admin does not have enough balance");

        entries = receipt.select(toString(adminAddr), condition);
        require(entries.size() <= 1, "receipt must not exist or be unique");

        // 4. 更新中小企业持有的凭证信息
        updateReceipt("Receipts_out", toString(addr), toString(msg.sender), timestamp, receiptAmount - amount);
        updateReceipt("Receipts_in", toString(msg.sender), toString(addr), timestamp, receiptAmount - amount);

        // 5. 将分割出的部分转移到银行的记录中
        if(entries.size() == 0) {
            insertReceipt("Receipts_out", toString(addr), adminAddr, amount, timestamp, validity);
            insertReceipt("Receipts_in", toString(adminAddr), addr, amount, timestamp, validity);
        }
        else {
            entry = entries.get(0);
            receiptAmount = entry.getUInt("amount");
            updateReceipt("Receipts_out", toString(addr), toString(adminAddr), timestamp, receiptAmount + amount);
            updateReceipt("Receipts_in", toString(adminAddr), toString(addr), timestamp, receiptAmount + amount);
        }

        // 6. 发放融资金额
        updateCompanyBalance(adminAddr, balance - amount);
        updateCompanyBalance(msg.sender, getCompanyBalance(msg.sender) + amount);

        // 7. 触发融资完成的事件
        emit CreditTransactionEvent(msg.sender, adminAddr, amount);
        emit BalanceTransactionEvent(adminAddr, msg.sender, amount);
        ```

4. 功能四：应收账款支付结算上链，应收账款单据到期时核心企业向下游企业支付相应的欠款。
    - 应用场景：车企给支付之前签发出去的票据，并销毁这些票据，同时信用值有一定的回升。
    - 分析：企业向所有持有该票据的其他企业支付应收款金额，回收信用凭证并销毁票据，该交易在调用合约时会被自动上链保证不可篡改
    - 合约接口设计：
        ```
        function arrearsPaying(uint timestamp) public
        ```
        - 时间戳：表示信用票据的签订的区块时间  

        时间戳则能追溯到唯一的票据，即便是已经被分割到多个企业手中，仍需要支付所有的应付金额。
    - 流程描述
        ```
        // 1. 追溯到那个时间戳签发出去的所有信用票据
        Table receipt = openTable("Receipts_out");
        Condition condition = receipt.newCondition();
        condition.EQ("timestamp", int(timestamp));
        Entries entries = receipt.select(toString(msg.sender), condition);

        // 2. 向持有该票据的企业逐个支付欠款金额。
        Entry entry;
        address addr;
        uint receiptAmount;
        uint validity;
        uint timestampNow = block.timestamp;
        uint balance;

        for (int i = 0; i < entries.size(); i++) {
            // 3. 检查信用票据的应收账款金额，并保证企业当前的余额足以支付欠款。
            entry = entries.get(i);
            addr = entry.getAddress("addr");
            receiptAmount = entry.getUInt("amount");
            validity = entry.getUInt("validity");
            balance = getCompanyBalance(msg.sender);
            require(balance >= receiptAmount, "You does not have enough balance");

            // 4. 销毁中小企业持有的凭证信息
            updateReceipt("Receipts_out", toString(msg.sender), toString(addr), timestamp, 0);
            updateReceipt("Receipts_in", toString(addr), toString(msg.sender), timestamp, 0);

            // 5. 支付应收款金额
            updateCompanyBalance(msg.sender, balance - receiptAmount);
            updateCompanyBalance(addr, getCompanyBalance(addr) + receiptAmount);

            // 6. 对信用凭证做回收，如果是在票据过期之前还款则全额返回，否则根据拖欠时间做一定的扣除。
            uint amount = 0;
            if(timestampNow > timestamp + validity) amount = (timestampNow - timestamp - validity) / 3600;
            updateCompanyCredit(msg.sender, getCompanyCredit(msg.sender) + receiptAmount - amount);

            // 7. 触发还款完成的事件
            emit CreditTransactionEvent(msg.sender, addr, receiptAmount);
            emit BalanceTransactionEvent(addr, msg.sender, receiptAmount);
        }
        ```

#### 另外的场景功能实现
- 信用凭证的查询
    - 应用场景：车企想要看自己发出的所有应收帐以方便优先还快要到期的应收帐目，保证其信用不会受损
    - 分析：需要筛选出与该车企关联的所有应收帐目并列出账目的详细信息，包括金额信息、时间信息等
    - 合约接口设计：
        ```
        function getReceiptsInList() public view returns (string[] memory amounts,string[] memory addresses,string[] memory timestamps,string[] memory validitys);
        function getReceiptsOutList() public view returns (string[] memory amounts,string[] memory addresses,string[] memory timestamps,string[] memory validitys);
        ```
        - 返回参数
            - 金额列表
            - 地址列表
            - 时间戳列表
            - 有效期列表

        我们使用合约调用者的地址来辨别身份，以减少公开信息；返回参数方面，经过测试发现在合约内进行字符串的拼接会有很大的gas花销，所以决定使用数组的形式直接返回数据，后续在服务端再进行处理
    - 流程描述
        ```
        // 1. 使用Table的select句柄来直接实现应收帐目的筛选
        Table company = openTable("Receipts_in");
        Entries entries = company.select(toString(msg.sender), company.newCondition());
        
        // 2. 遍历筛选结果，返回相应的详细信息列表
        int size = entries.size();
        Receipt[] memory list = new Receipt[](uint256(size));
        for(int i = 0; i < size; i++){
            //有则返回
            list[uint(i)] = Receipt(entries.get(i).getUInt("amount"), entries.get(i).getAddress("from"), entries.get(i).getUInt("timestamp"), entries.get(i).getUInt("validity"));
        }
        return ResceiptsToString(list);
        ```